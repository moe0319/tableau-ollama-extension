<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ollama Tableau Integration</title>

    <script src="https://cdn.jsdelivr.net/npm/@tableau/extensions-api/lib/tableau.extensions.1.latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            padding: 15px;
            max-width: 800px;
            margin: 0 auto;
        }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        textarea, select, input {
            width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box;
        }
        button {
            background-color: #2e77d0; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer;
        }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        #response-area {
            min-height: 150px; border: 1px solid #ddd; border-radius: 4px; padding: 10px;
            margin-top: 10px; background-color: #f9f9f9; white-space: pre-wrap; font-family: monospace;
        }
        .spinner { display: none; margin-left: 10px; vertical-align: middle; }
        .error { color: #dc3545; margin-top: 10px; }
        .success { color: #28a745; margin-top: 10px; }
        .warning {
            background-color: #fff3cd; border: 1px solid #ffeeba; color: #856404;
            padding: 10px; margin-bottom: 15px; border-radius: 4px;
        }
        .sheet-selector {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .sheet-selector input[type="checkbox"] {
            margin-right: 5px;
        }
        .column-selector {
            margin-top: 5px;
            margin-left: 20px;
            padding: 5px;
            border-left: 1px solid #ddd;
            display: none;
        }
    </style>
</head>
<body>
    <h2>Ollama Tableau 拡張機能</h2>
    <div class="warning">
        <strong>重要:</strong> CORS制限回避のため、CORS拡張機能を使うかEdgeを特別モード(--disable-web-security)で起動してください。
    </div>

    <div class="form-group">
        <label for="ollama-url">Ollama サーバーURL:</label>
        <input type="text" id="ollama-url" value="http://localhost:8889" placeholder="http://localhost:8889">
    </div>

    <div class="form-group">
        <label for="model-select">モデル:</label>
        <select id="model-select">
            <option value="phi4">phi4</option>
            <option value="llama2">llama2</option>
            <option value="mistral">mistral</option>
            <option value="gemma">gemma</option>
        </select>
    </div>

    <div class="form-group">
        <label for="prompt-input">プロンプト:</label>
        <textarea id="prompt-input" rows="4" placeholder="Ollamaに送信するプロンプトを入力してください..."></textarea>
    </div>

    <div style="margin-bottom: 15px;">
        <input type="checkbox" id="include-data" checked>
        <label for="include-data" style="display: inline;">ダッシュボードのデータを含める</label>
        <button id="reload-button" style="margin-left: 10px;">再読み込み</button>
    </div>

    <div id="sheets-container" style="display: none;">
        <h3>使用するワークシート:</h3>
        <div id="sheet-status"></div>
        <div id="sheet-selectors">
            <!-- シート選択がここに動的に生成されます -->
        </div>
    </div>

    <div class="form-group" id="data-format-group" style="display: none;">
        <label for="data-format-select">データフォーマット:</label>
        <select id="data-format-select">
            <option value="raw">テキスト形式</option>
            <option value="table">テーブル形式</option>
            <option value="json">JSON形式</option>
        </select>
    </div>

    <button id="preview-button" style="display: none; margin-right: 10px;">プレビュー</button>
    <button id="send-button">送信</button>
    <span class="spinner" id="spinner">処理中...</span>

    <div id="status-message"></div>

    <div class="form-group" id="preview-group" style="display: none;">
        <label for="data-preview">データプレビュー:</label>
        <div id="data-preview" style="overflow-x:auto; border:1px solid #ddd; padding:10px; background:#f1f1f1; font-family:monospace; max-height: 300px; overflow-y: auto;"></div>
    </div>

    <div class="form-group">
        <label for="response-area">Ollamaの応答:</label>
        <div id="response-area"></div>
    </div>

    <script>
        let dashboard;
        let sheetsMeta = [];
        
        // タブローが読み込まれたかどうかをチェックする関数
        function isTableauInitialized() {
            return typeof tableau !== 'undefined' && 
                   tableau.extensions && 
                   tableau.extensions.dashboardContent && 
                   tableau.extensions.dashboardContent.dashboard;
        }
        
        // func.jsからインポートする関数のエミュレーション
        const initializeMeta = async () => {
            console.log('Initializing Meta');
            const statusElement = document.getElementById('sheet-status');
            if (statusElement) {
                statusElement.innerHTML = '<div class="warning">ワークシートデータを読み込み中...</div>';
            }
            
            let meta = [];
            
            try {
                // Make sure tableau extensions exist and are loaded
                if (!isTableauInitialized()) {
                    console.error('Tableau Extensions API not available');
                    if (statusElement) {
                        statusElement.innerHTML = '<div class="error">Tableau Extensions APIが利用できません</div>';
                    }
                    return [];
                }
                
                const dashboard = tableau.extensions.dashboardContent.dashboard;
                if (!dashboard) {
                    console.error('Dashboard not available');
                    if (statusElement) {
                        statusElement.innerHTML = '<div class="error">ダッシュボードが見つかりません</div>';
                    }
                    return [];
                }
                
                const worksheets = dashboard.worksheets;
                console.log(`Found ${worksheets.length} worksheets in dashboard`);
                
                if (worksheets.length === 0) {
                    if (statusElement) {
                        statusElement.innerHTML = '<div class="warning">ダッシュボードにワークシートが見つかりません</div>';
                    }
                    return [];
                }
                
                for (let i = 0; i < worksheets.length; i++) {
                    const sheet = worksheets[i];
                    console.log(`Processing worksheet: ${sheet.name}`);
                    
                    if (statusElement) {
                        statusElement.innerHTML = `<div class="warning">ワークシート「${sheet.name}」を処理中...</div>`;
                    }
                    
                    let item = {
                        sheetName: sheet.name,
                        selected: true, // Default to selected
                        changeName: null,
                        customCols: false
                    };
                    
                    try {
                        // First try with ignoreSelection: true
                        let data;
                        try {
                            data = await sheet.getSummaryDataAsync({ignoreSelection: true});
                        } catch (innerError) {
                            console.warn(`Failed to get data with ignoreSelection true for ${sheet.name}:`, innerError);
                            // Try again without ignoreSelection
                            data = await sheet.getSummaryDataAsync();
                        }
                        
                        if (!data || !data.columns) {
                            console.warn(`No data returned for ${sheet.name}`);
                            item.columns = [];
                            continue;
                        }
                        
                        const columns = data.columns;
                        console.log(`Found ${columns.length} columns in ${sheet.name}`);
                        
                        let cols = [];
                        for (let k = 0; k < columns.length; k++) {
                            let newCol = {};
                            newCol.index = columns[k].index;
                            newCol.name = columns[k].fieldName;
                            newCol.dataType = columns[k].dataType;
                            newCol.selected = true;
                            newCol.order = k + 1;
                            cols.push(newCol);
                        }
                        
                        item.columns = cols;
                    } catch (error) {
                        console.error(`Error getting data for ${sheet.name}:`, error);
                        item.columns = [];
                        item.error = error.message;
                    }
                    
                    meta.push(item);
                }
                
                if (statusElement) {
                    statusElement.innerHTML = `<div class="success">${meta.length}個のワークシートを読み込みました</div>`;
                }
                
                return meta;
            } catch (error) {
                console.error('Error in initializeMeta:', error);
                if (statusElement) {
                    statusElement.innerHTML = `<div class="error">エラー: ${error.message}</div>`;
                }
                return [];
            }
        };
        
        const decodeDataset = async (columns, dataset) => {
            let rows = [];
            for (let i = 0; i < dataset.length; i++) {
                rows.push(await decodeRow(columns, dataset[i]));
            }
            return rows;
        };
        
        const decodeRow = async (columns, row) => {
            let meta = {};
            for (let j = 0; j < columns.length; j++) {
                if (columns[j].selected) {
                    let val;
                    if (row[j].value === '%null%' && row[j].nativeValue === null && row[j].formattedValue === 'Null') {
                        val = null;
                    } else {
                        val = row[j].formattedValue;
                    }
                    meta[columns[j].outputName || columns[j].name] = val;
                }
            }
            return meta;
        };

                document.addEventListener('DOMContentLoaded', function () {
            console.log('DOM Content Loaded');
            
            // Check if tableau is available
            if (typeof tableau !== 'undefined') {
                console.log('Tableau object exists, initializing extension...');
                
                // Initialize the extension
                tableau.extensions.initializeAsync().then(async function () {
                    console.log('Extension initialized successfully');
                    
                    if (isTableauInitialized()) {
                        dashboard = tableau.extensions.dashboardContent.dashboard;
                        console.log('Dashboard loaded:', dashboard.name);
                        console.log('Worksheets found:', dashboard.worksheets.length);
                        
                        // Log worksheet names for debugging
                        dashboard.worksheets.forEach(ws => {
                            console.log('Worksheet found:', ws.name);
                        });
                        
                        sheetsMeta = await initializeMeta();
                        console.log('Sheet meta initialized:', sheetsMeta);
                    } else {
                        console.error('Tableau dashboard not available after initialization');
                        showError('Tableauダッシュボードが利用できません');
                    }
                    
                    setupEventListeners();
                    toggleDataOptions(); // Make sure data options are visible if include-data is checked
                    renderSheetSelectors();
                    testOllamaConnection();
                }).catch(function (err) {
                    showError('初期化に失敗しました: ' + err);
                    console.error('Initialization error:', err);
                });
            } else {
                console.warn('Tableau object is not defined. Running in standalone mode.');
                showWarning('Tableau拡張機能として実行されていません。一部の機能が制限されます。');
                
                setupEventListeners();
                toggleDataOptions();
                testOllamaConnection();
            }
        });

        function setupEventListeners() {
            document.getElementById('send-button').addEventListener('click', sendPrompt);
            document.getElementById('ollama-url').addEventListener('change', testOllamaConnection);
            document.getElementById('include-data').addEventListener('change', toggleDataOptions);
            document.getElementById('reload-button').addEventListener('click', reloadExtension);
            
            if (document.getElementById('preview-button')) {
                document.getElementById('preview-button').addEventListener('click', showDataPreview);
            }
        }
        
        async function reloadExtension() {
            const statusElement = document.getElementById('sheet-status');
            if (statusElement) {
                statusElement.innerHTML = '<div class="warning">拡張機能を再読み込み中...</div>';
            }
            
            try {
                // Check if tableau is defined
                if (!isTableauInitialized()) {
                    showError('Tableau Extensions APIが読み込まれていません');
                    if (statusElement) {
                        statusElement.innerHTML = '<div class="error">Tableau Extensions APIが利用できません</div>';
                    }
                    return;
                }
                
                dashboard = tableau.extensions.dashboardContent.dashboard;
                console.log('Dashboard reloaded:', dashboard.name);
                console.log('Worksheets found:', dashboard.worksheets.length);
                
                // Re-initialize sheets
                sheetsMeta = await initializeMeta();
                console.log('Sheet meta reinitialized:', sheetsMeta);
                
                // Make sure data options are visible if include-data is checked
                toggleDataOptions();
                
                // Render sheet selectors
                renderSheetSelectors();
                
                showSuccess('拡張機能を再読み込みしました');
            } catch (err) {
                showError('再読み込み失敗: ' + err.message);
                console.error('Reload error:', err);
            }
        }

        function toggleDataOptions() {
            const includeData = document.getElementById('include-data').checked;
            document.getElementById('sheets-container').style.display = includeData ? 'block' : 'none';
            document.getElementById('data-format-group').style.display = includeData ? 'block' : 'none';
            document.getElementById('preview-button').style.display = includeData ? 'inline-block' : 'none';
            
            // Force update the sheet selectors when toggling
            if (includeData && typeof tableau !== 'undefined') {
                renderSheetSelectors();
            }
        }

        function renderSheetSelectors() {
            const container = document.getElementById('sheet-selectors');
            if (!container) {
                console.error('sheet-selectors container not found');
                return;
            }
            
            // Clear the container
            container.innerHTML = '';
            console.log('Rendering sheet selectors for', sheetsMeta.length, 'sheets');
            
            // If no sheets, display message
            if (!sheetsMeta || sheetsMeta.length === 0) {
                const noSheetsDiv = document.createElement('div');
                noSheetsDiv.className = 'warning';
                noSheetsDiv.textContent = 'ワークシートが見つかりません。再読み込みしてください。';
                container.appendChild(noSheetsDiv);
                
                // Add reload button
                const reloadBtn = document.createElement('button');
                reloadBtn.textContent = '再読み込み';
                reloadBtn.style.marginTop = '10px';
                reloadBtn.addEventListener('click', async () => {
                    try {
                        // Reinitialize
                        dashboard = tableau.extensions.dashboardContent.dashboard;
                        sheetsMeta = await initializeMeta();
                        renderSheetSelectors();
                        showSuccess('再読み込みしました');
                    } catch (err) {
                        showError('再読み込み失敗: ' + err.message);
                    }
                });
                container.appendChild(reloadBtn);
                return;
            }
            
            // Manual alternative if Tableau Extensions API isn't working
            if (sheetsMeta.length === 0 && typeof tableau !== 'undefined') {
                // Try direct access to worksheets
                try {
                    const worksheets = tableau.extensions.dashboardContent.dashboard.worksheets;
                    console.log('Direct worksheet access found', worksheets.length, 'sheets');
                    
                    // Create manual entries for each worksheet
                    worksheets.forEach((sheet, index) => {
                        console.log('Adding worksheet from direct access:', sheet.name);
                        
                        const sheetDiv = document.createElement('div');
                        sheetDiv.className = 'sheet-selector';
                        
                        const sheetCheckbox = document.createElement('input');
                        sheetCheckbox.type = 'checkbox';
                        sheetCheckbox.id = `direct-sheet-${index}`;
                        sheetCheckbox.checked = true;
                        
                        const sheetLabel = document.createElement('label');
                        sheetLabel.htmlFor = `direct-sheet-${index}`;
                        sheetLabel.style.display = 'inline';
                        sheetLabel.textContent = sheet.name;
                        
                        sheetDiv.appendChild(sheetCheckbox);
                        sheetDiv.appendChild(sheetLabel);
                        container.appendChild(sheetDiv);
                    });
                } catch (err) {
                    console.error('Direct worksheet access failed:', err);
                }
            }
            
            // Render sheets from sheetsMeta
            sheetsMeta.forEach((sheetMeta, index) => {
                console.log('Rendering sheet selector for:', sheetMeta.sheetName);
                
                const sheetDiv = document.createElement('div');
                sheetDiv.className = 'sheet-selector';
                
                const sheetCheckbox = document.createElement('input');
                sheetCheckbox.type = 'checkbox';
                sheetCheckbox.id = `sheet-${index}`;
                sheetCheckbox.checked = true; // Default to checked
                sheetCheckbox.addEventListener('change', (e) => {
                    sheetsMeta[index].selected = e.target.checked;
                    const columnsDiv = document.getElementById(`columns-${index}`);
                    if (columnsDiv) {
                        columnsDiv.style.display = e.target.checked ? 'block' : 'none';
                    }
                });
                
                // Set the selected state in the metadata
                sheetsMeta[index].selected = true;
                
                const sheetLabel = document.createElement('label');
                sheetLabel.htmlFor = `sheet-${index}`;
                sheetLabel.style.display = 'inline';
                sheetLabel.textContent = sheetMeta.sheetName;
                
                sheetDiv.appendChild(sheetCheckbox);
                sheetDiv.appendChild(sheetLabel);
                
                // カラム選択コンテナを作成
                const columnsDiv = document.createElement('div');
                columnsDiv.id = `columns-${index}`;
                columnsDiv.className = 'column-selector';
                columnsDiv.style.display = 'block'; // Make columns visible by default
                
                if (sheetMeta.columns && sheetMeta.columns.length > 0) {
                    sheetMeta.columns.forEach((column, colIndex) => {
                        const colDiv = document.createElement('div');
                        
                        const colCheckbox = document.createElement('input');
                        colCheckbox.type = 'checkbox';
                        colCheckbox.id = `col-${index}-${colIndex}`;
                        colCheckbox.checked = true; // Default all columns to checked
                        colCheckbox.addEventListener('change', (e) => {
                            sheetsMeta[index].columns[colIndex].selected = e.target.checked;
                        });
                        
                        // Set the selected state in the metadata
                        sheetsMeta[index].columns[colIndex].selected = true;
                        
                        const colLabel = document.createElement('label');
                        colLabel.htmlFor = `col-${index}-${colIndex}`;
                        colLabel.style.display = 'inline';
                        colLabel.textContent = column.name;
                        
                        colDiv.appendChild(colCheckbox);
                        colDiv.appendChild(colLabel);
                        columnsDiv.appendChild(colDiv);
                    });
                } else {
                    // Show loading message if no columns
                    const loadingMsg = document.createElement('div');
                    loadingMsg.textContent = 'カラム情報を読み込み中...';
                    columnsDiv.appendChild(loadingMsg);
                }
                
                sheetDiv.appendChild(columnsDiv);
                container.appendChild(sheetDiv);
            });
        }

        async function showDataPreview() {
            const preview = document.getElementById('data-preview');
            const previewGroup = document.getElementById('preview-group');
            previewGroup.style.display = 'block';
            preview.textContent = '読み込み中...';
            
            const format = document.getElementById('data-format-select').value;
            const selectedSheets = sheetsMeta.filter(s => s.selected);
            
            if (selectedSheets.length === 0) {
                preview.textContent = 'シートが選択されていません。';
                return;
            }
            
            try {
                const previewData = await getFormattedData(format);
                preview.textContent = previewData;
            } catch (err) {
                preview.textContent = 'プレビュー取得失敗: ' + err.message;
            }
        }

        async function getFormattedData(format) {
            if (!isTableauInitialized()) {
                console.error('Tableau is not initialized, cannot get data');
                return 'Tableauからデータを取得できません。';
            }
            
            const selectedSheets = sheetsMeta.filter(s => s.selected);
            const worksheets = tableau.extensions.dashboardContent.dashboard.worksheets;
            let formattedData = '';
            
            if (selectedSheets.length === 0) {
                return '選択されたシートがありません。';
            }
            
            switch (format) {
                case 'raw':
                    for (const sheetMeta of selectedSheets) {
                        const sheet = worksheets.find(ws => ws.name === sheetMeta.sheetName);
                        if (!sheet) continue;
                        
                        try {
                            const data = await sheet.getSummaryDataAsync({ignoreSelection: true});
                            const selectedColumns = sheetMeta.columns.filter(col => col.selected);
                            const columnNames = selectedColumns.map(col => col.name);
                            
                            formattedData += `# ${sheetMeta.sheetName}\n`;
                            formattedData += columnNames.join('\t') + '\n';
                            
                            for (let i = 0; i < data.data.length; i++) {
                                const row = data.data[i];
                                const formattedRow = selectedColumns.map(col => {
                                    const colIndex = sheetMeta.columns.findIndex(c => c.name === col.name);
                                    return row[colIndex].formattedValue || row[colIndex].value || '';
                                }).join('\t');
                                formattedData += formattedRow + '\n';
                            }
                            formattedData += '\n';
                        } catch (error) {
                            console.error(`Error getting data for ${sheet.name}:`, error);
                            formattedData += `# ${sheetMeta.sheetName}\nデータ取得エラー: ${error.message}\n\n`;
                        }
                    }
                    break;
                    
                case 'table':
                    for (const sheetMeta of selectedSheets) {
                        const sheet = worksheets.find(ws => ws.name === sheetMeta.sheetName);
                        if (!sheet) continue;
                        
                        try {
                            const data = await sheet.getSummaryDataAsync({ignoreSelection: true});
                            const selectedColumns = sheetMeta.columns.filter(col => col.selected);
                            
                            formattedData += `# ${sheetMeta.sheetName}\n`;
                            formattedData += '| ' + selectedColumns.map(col => col.name).join(' | ') + ' |\n';
                            formattedData += '| ' + selectedColumns.map(() => '---').join(' | ') + ' |\n';
                            
                            for (let i = 0; i < Math.min(data.data.length, 50); i++) {
                                const row = data.data[i];
                                const formattedRow = selectedColumns.map(col => {
                                    const colIndex = sheetMeta.columns.findIndex(c => c.name === col.name);
                                    return row[colIndex].formattedValue || row[colIndex].value || '';
                                }).join(' | ');
                                formattedData += '| ' + formattedRow + ' |\n';
                            }
                            formattedData += '\n';
                        } catch (error) {
                            console.error(`Error getting data for ${sheet.name}:`, error);
                            formattedData += `# ${sheetMeta.sheetName}\nデータ取得エラー: ${error.message}\n\n`;
                        }
                    }
                    break;
                    
                case 'json':
                    const jsonData = {};
                    
                    for (const sheetMeta of selectedSheets) {
                        const sheet = worksheets.find(ws => ws.name === sheetMeta.sheetName);
                        if (!sheet) continue;
                        
                        try {
                            const data = await sheet.getSummaryDataAsync({ignoreSelection: true});
                            const selectedColumns = sheetMeta.columns.filter(col => col.selected);
                            
                            const columns = data.columns.map((col, idx) => {
                                const colMeta = selectedColumns.find(c => c.name === col.fieldName);
                                if (colMeta) {
                                    return { ...col, selected: true, outputName: colMeta.changeName || colMeta.name };
                                } else {
                                    return { ...col, selected: false };
                                }
                            }).filter(col => col.selected);
                            
                            const rows = await decodeDataset(columns, data.data);
                            jsonData[sheetMeta.sheetName] = rows;
                        } catch (error) {
                            console.error(`Error getting data for ${sheet.name}:`, error);
                            jsonData[sheetMeta.sheetName] = { error: error.message };
                        }
                    }
                    
                    formattedData = JSON.stringify(jsonData, null, 2);
                    break;
            }
            
            return formattedData;
        }eetMeta.sheetName}\n`;
                        formattedData += columnNames.join('\t') + '\n';
                        
                        for (let i = 0; i < data.data.length; i++) {
                            const row = data.data[i];
                            const formattedRow = selectedColumns.map(col => {
                                const colIndex = sheetMeta.columns.findIndex(c => c.name === col.name);
                                return row[colIndex].formattedValue || row[colIndex].value || '';
                            }).join('\t');
                            formattedData += formattedRow + '\n';
                        }
                        formattedData += '\n';
                    }
                    break;
                    
                case 'table':
                    for (const sheetMeta of selectedSheets) {
                        const sheet = worksheets.find(ws => ws.name === sheetMeta.sheetName);
                        if (!sheet) continue;
                        
                        const data = await sheet.getSummaryDataAsync({ignoreSelection: true});
                        const selectedColumns = sheetMeta.columns.filter(col => col.selected);
                        
                        formattedData += `# ${sheetMeta.sheetName}\n`;
                        formattedData += '| ' + selectedColumns.map(col => col.name).join(' | ') + ' |\n';
                        formattedData += '| ' + selectedColumns.map(() => '---').join(' | ') + ' |\n';
                        
                        for (let i = 0; i < Math.min(data.data.length, 50); i++) {
                            const row = data.data[i];
                            const formattedRow = selectedColumns.map(col => {
                                const colIndex = sheetMeta.columns.findIndex(c => c.name === col.name);
                                return row[colIndex].formattedValue || row[colIndex].value || '';
                            }).join(' | ');
                            formattedData += '| ' + formattedRow + ' |\n';
                        }
                        formattedData += '\n';
                    }
                    break;
                    
                case 'json':
                    const jsonData = {};
                    
                    for (const sheetMeta of selectedSheets) {
                        const sheet = worksheets.find(ws => ws.name === sheetMeta.sheetName);
                        if (!sheet) continue;
                        
                        const data = await sheet.getSummaryDataAsync({ignoreSelection: true});
                        const selectedColumns = sheetMeta.columns.filter(col => col.selected);
                        
                        const columns = data.columns.map((col, idx) => {
                            const colMeta = selectedColumns.find(c => c.name === col.fieldName);
                            if (colMeta) {
                                return { ...col, selected: true, outputName: colMeta.changeName || colMeta.name };
                            } else {
                                return { ...col, selected: false };
                            }
                        }).filter(col => col.selected);
                        
                        const rows = await decodeDataset(columns, data.data);
                        jsonData[sheetMeta.sheetName] = rows;
                    }
                    
                    formattedData = JSON.stringify(jsonData, null, 2);
                    break;
            }
            
            return formattedData;
        }

        async function testOllamaConnection() {
            const ollamaUrl = document.getElementById('ollama-url').value.trim();
            try {
                const response = await fetch(ollamaUrl, { method: 'GET' });
                if (response.ok) showSuccess('Ollamaサーバーに接続できました');
                else showError('応答エラー: ' + response.status);
            } catch (error) {
                showError('接続失敗: ' + error.message);
            }
        }

        async function sendPrompt() {
            const ollamaUrl = document.getElementById('ollama-url').value.trim();
            const modelName = document.getElementById('model-select').value;
            const promptInput = document.getElementById('prompt-input').value.trim();
            const includeData = document.getElementById('include-data').checked;
            const responseArea = document.getElementById('response-area');
            const spinner = document.getElementById('spinner');
            const sendButton = document.getElementById('send-button');

            if (!promptInput) {
                alert('プロンプトを入力してください');
                return;
            }

            spinner.style.display = 'inline';
            sendButton.disabled = true;
            responseArea.textContent = '処理中...';
            showStatus('送信中...');

            let finalPrompt = promptInput;
            
            if (includeData) {
                try {
                    if (isTableauInitialized()) {
                        const format = document.getElementById('data-format-select').value;
                        const formattedData = await getFormattedData(format);
                        
                        if (formattedData) {
                            finalPrompt = `以下のTableauデータを分析して回答してください:

${formattedData}

質問: ${promptInput}`;
                        }
                    } else {
                        showWarning('Tableauデータにアクセスできません。プロンプトのみを送信します。');
                    }
                } catch (error) {
                    showError('データ取得失敗: ' + error.message);
                    spinner.style.display = 'none';
                    sendButton.disabled = false;
                    return;
                }
            }

            try {
                const response = await fetch(`${ollamaUrl}/api/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model: modelName, prompt: finalPrompt, stream: false })
                });
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                responseArea.textContent = data.response || 'レスポンスが空です';
                showSuccess('応答を受信しました');
            } catch (error) {
                showError('送信失敗: ' + error.message);
                responseArea.textContent = '';
            } finally {
                spinner.style.display = 'none';
                sendButton.disabled = false;
            }
        }

        function showError(msg) {
            const status = document.getElementById('status-message');
            status.textContent = msg; status.className = 'error';
        }
        function showSuccess(msg) {
            const status = document.getElementById('status-message');
            status.textContent = msg; status.className = 'success';
        }
        function showStatus(msg) {
            const status = document.getElementById('status-message');
            status.textContent = msg; status.className = '';
        }
        function showWarning(msg) {
            const status = document.getElementById('status-message');
            status.textContent = msg; status.className = 'warning';
        }
    </script>
</body>
</html>
